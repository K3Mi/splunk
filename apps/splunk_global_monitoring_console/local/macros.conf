[Search_Head_Cluster]
definition = host IN (123)
iseval = 0

[Splunk_Heavy_Forwarders]
definition = hostname IN (123)
iseval = 0

[Indexer_Cluster]
definition = host IN (123)
iseval = 0

[Search_Heads]
definition = host IN (123)
iseval = 0

[Splunk_Role]
definition = eval Splunk_Role = case ( \
    match(search_group, "PROD-IDXC-1$") OR match(host, "^\w+-SPLN?K-IN?DX\d+"), "PROD-IDXC-1", \
    match(search_group, "PROD-IDXC-2$"), "PROD-IDXC-2",\
    match(search_group, "PROD-CM-1$") OR match(host, "123"), "PROD-CM-1", \
    match(search_group, "PROD-CM-2$") OR match(host, "123"), "PROD-CM-2", \
    match(search_group, "PROD-HF-1$"), "PROD-HF-1",\
    match(search_group, "PROD-LM-1$") OR match(host, "123"), "PROD-LM-1",\
    match(search_group, "PROD-MC-1$"), "PROD-MC-1",\
    match(search_group, "PROD-MC-2$"), "PROD-MC-2",\
    match(search_group, "PROD-SH$"), "PROD-SH",\
    match(search_group, "PROD-SHC-1$"), "PROD-SHC-1",\
    match(search_group, "PROD-SHC-2$"), "PROD-SHC-2", \
    match(search_group, "PROD-SHC-DP-1$"), "PROD-SHC-DP-1", \
    match(search_group, "PROD-SHC-DP-2$"), "PROD-SHC-DP-2", \
    match(search_group, "PROD-DS-1$"), "PROD-DS-1",\
    match(search_group, "PROD-DS-2$") OR match(host, "123"), "PROD-DS-2",\
    match(search_group, "PROD-ITSI-1$") OR match(host, "123|123|123"), "PROD-ITSI-1", \
    match(search_group, "UAT-CM-1$"), "UAT-CM-1", \
    match(search_group, "UAT-HF-1$"), "UAT-HF-1", \
    match(search_group, "UAT-IDXC-1$"), "UAT-IDXC-1",\
    match(search_group, "UAT-SHC-1$") OR match(host, "123"), "UAT-SHC-1",\
    match(search_group, "UAT-HF-1$") OR match(host, "123|123|123|123|123|123|123"), "UAT-HF-1",\
    match(search_group, "DEV-SHC-1$") OR match(host, "123|123|123"), "DEV-SHC-1",\
    match(search_group, "DEV-IDXC-1$"), "DEV-IDXC-1",\
    match(search_group, "DEV-CM-1$") OR match(host, "123"), "DEV-CM-1",\
    match(search_group, "DEV-DS-1$"), "DEV-DS-1",\
    match(search_group, "DEV-LM-1$"), "DEV-LM-1",\
    true(), null() ) \
| eval host_lookup = if ( isnull(Splunk_Role), lower(host), null() ) \
| lookup dmc_assets host AS host_lookup OUTPUT search_group AS search_group_lookup \
| eval search_group_lookup = mvfilter ( match (search_group_lookup, "^dmc_customgroup_") ) \
| rex field=search_group_lookup mode=sed "s/^dmc_customgroup_//g" \
| eval Splunk_Role = mvappend (Splunk_Role, search_group_lookup)\
| fields - host_lookup search_group_lookup
iseval = 0
disabled = 1

[cron_schedule(1)]
args = cron_schedule
definition = rex field=$cron_schedule$ "(?<Minute>^.*?)\\s(?<Hour>.*?)\\s(?<Day_of_Month>.*?)\\s(?<Month>.*?)\\s(?<Day_of_Week>.*?)$" \
| eval \
    Minute = case ( \
    (Minute == "*"),"Any", \
    true(), Minute ), \
    Hour = if ( match(Hour,"^\\*"),"Any",Hour ),\
    Day_of_Week = case ( \
    (Day_of_Week == 0 OR Day_of_Week == 7),"Sunday", \
    (Day_of_Week == 1), "Monday",\
    (Day_of_Week == 2), "Tuesday",\
    (Day_of_Week == 3), "Wednesday",\
    (Day_of_Week == 4), "Thursday",\
    (Day_of_Week == 5), "Friday",\
    (Day_of_Week == 6), "Saturday", \
    (Day_of_Week == "*"),"Any", \
    true(), Day_of_Week),\
    Day_of_Month = if ( match(Day_of_Month,"^\\*"), "Any", Day_of_Month), \
    Month = case ( \
    (Month == 1),"January",\
    (Month == 2),"February",\
    (Month == 3),"March",\
    (Month == 4),"April",\
    (Month == 5),"May",\
    (Month == 6),"June",\
    (Month == 7),"July",\
    (Month == 8),"August",\
    (Month == 9),"September",\
    (Month == 10),"October",\
    (Month == 11),"November",\
    (Month == 12),"December", \
    (Month == "*"),"Any", \
    true(), Month ), \
    Cron_Schedule_translated=((((((((("Minute: " . Minute) . " | Hour: ") . Hour) . " | Day_of_Month: ") . Day_of_Month) . " | Month: ") . Month) . " | Day_of_Week: ") . Day_of_Week)\
| fields - Minute, Hour, Day_of_Month, Month, Day_of_Week
iseval = 0

[gmc_convert_runtime(1)]
args = runtime
definition = eval $runtime$ = case( \
round($runtime$ / (3600*24) - 0.5) > 0, round($runtime$ / (3600*24) - 0.5)."d ".round(($runtime$ % (3600*24)) / 3600 - 0.5)."h ".round(($runtime$ % 3600) / 60 - 0.5)."min ".round($runtime$ % 60, 2)."s", \
round(($runtime$ % (3600*24)) / 3600 - 0.5) > 0, round(($runtime$ % (3600*24)) / 3600 - 0.5)."h ".round(($runtime$ % 3600) / 60 - 0.5)."min ".round($runtime$ % 60, 2)."s", \
round(($runtime$ % 3600) / 60 - 0.5) > 0, round(($runtime$ % 3600) / 60 - 0.5)."min ".round($runtime$ % 60, 2)."s", \
1 = 1, round($runtime$ % 60, 2)."s" \
)
iseval = 0

[get_saved_searches_info(3)]
args = Splunk_Role,App,Savedsearch_Name
definition = lookup shc_saved_searches_rest_kv_store_lookup Splunk_Role AS $Splunk_Role$ app AS $App$ savedsearch_name AS $Savedsearch_Name$ OUTPUTNEW description savedsearch_type cron_schedule scheduled_times next_scheduled_time auto_summarize dispatch_earliest_time dispatch_latest_time schedule_priority max_concurrent schedule_window allow_skew realtime_schedule alert_severity alert_track alert_type removable run_n_times run_on_startup Lookup_Reference Datamodel_Reference search\
\
| fillnull value="Undefined" description savedsearch_type cron_schedule scheduled_times next_scheduled_time auto_summarize dispatch_earliest_time dispatch_latest_time schedule_priority max_concurrent schedule_window allow_skew realtime_schedule alert_severity alert_track alert_type removable run_n_times run_on_startup Lookup_Reference Datamodel_Reference search
iseval = 0

[get_saved_searches_info(2)]
args = App,Savedsearch_Name
definition = lookup shc_saved_searches_rest_kv_store_lookup app AS $App$ savedsearch_name AS $Savedsearch_Name$ OUTPUTNEW description savedsearch_type cron_schedule scheduled_times next_scheduled_time auto_summarize dispatch_earliest_time dispatch_latest_time schedule_priority max_concurrent schedule_window allow_skew realtime_schedule alert_severity alert_track alert_type removable run_n_times run_on_startup Lookup_Reference Datamodel_Reference search \
| fillnull value="Undefined" description savedsearch_type cron_schedule scheduled_times next_scheduled_time auto_summarize dispatch_earliest_time dispatch_latest_time schedule_priority max_concurrent schedule_window allow_skew realtime_schedule alert_severity alert_track alert_type removable run_n_times run_on_startup Lookup_Reference Datamodel_Reference search
iseval = 0

[get_dashboards_info(2)]
args = App,Title
definition = lookup splunk_sh_rest_data_ui_dashboards_lookup app AS $App$ title AS $Title$ OUTPUTNEW sharing title label description type dashboard_size author location removable updated data Report_Reference Dashboard_Reference Lookup_Reference Datamodel_Reference Search BaseSearch \
| fillnull value="Undefined" sharing title label description type dashboard_size author location removable updated data Report_Reference Dashboard_Reference Lookup_Reference Datamodel_Reference Search BaseSearch
iseval = 0



# From SA-Utils

#####################
## Boolean
#####################

## str_to_bool
[str_to_bool(1)]
args = field
definition = `str_to_bool($field$,$field$)`

[str_to_bool_meval(1)]
args = field
definition = `str_to_bool_meval($field$,$field$)`

[str_to_bool(2)]
args = inField,outField
definition = eval `str_to_bool_meval($inField$,$outField$)`

[str_to_bool_meval(2)]
args = inField,outField
definition = "$outField$"=case(match('$inField$', "1|[Tt]|[Tt][Rr][Uu][Ee]"),"true",match('$inField$', "0|[Ff]|[Ff][Aa][Ll][Ss][Ee]"),"false",1=1,'$inField$')


#####################
## Charting
#####################
[autopause]
definition = 120

[round(1)]
args = field
definition = `round("$field$",2)`

[round(2)]
args = field,precision
definition = `round("$field$","$field$",$precision$)`

[round(3)]
args = inField,outField,precision
definition = eval "$outField$"=round('$inField$',$precision$)
errormsg = precision (arg3) must be an integer greater than zero
iseval = 0
validation = isint(precision) AND precision>0

[wrap(2)]
args = field,length
definition = rex field="$field$" max_match=0 "(?<$field$>.{1,$length$})"
errormsg = length (arg2) must be an integer greater than zero
iseval = 0
validation = isint(length) AND length>0


#####################
## Date/Time
#####################

## create simple date field
[get_date(1)]
args = field
definition = eval date='$field$' | `ctime(date,"%m-%d-%Y")`

## convert epoch time to string
[ctime(1)]
args = field
definition = `ctime($field$,"%m/%d/%Y %H:%M:%S")`

## convert epoch time to string w/ format
[ctime(2)]
args = field,format
definition = convert timeformat="$format$" ctime($field$)

[ctime(3)]
args = inField,outField,format
definition = `ctime($inField$,"$format$")` as $outField$

## convert string to epoch time
[mktime(1)]
args = field
definition = `mktime($field$,"%m/%d/%Y %H:%M:%S")`

## convert string w/ format to epoch time
[mktime(2)]
args = field,format
definition = convert timeformat="$format$" mktime($field$)

[mktime(3)]
args = inField,outField,format
definition = `mktime($inField$,"$format$")` as $outField$

## format epoch time
[uitime(1)]
args = field
definition = `uitime($field$,"%m/%d/%Y %H:%M:%S")`

## format epoch time w/ format
[uitime(2)]
args = field,format
definition = fieldformat "$field$"=strftime('$field$', "$format$")

## convert uptime (# secs) to string
[uptime2string(2)]
args = inField,outField
definition = eval days_dec='$inField$'/86400 | eval days=floor(days_dec) | eval hours_dec=('$inField$'/3600)-(days*24) | eval hours=floor(hours_dec) | eval minutes_dec=('$inField$'/60)-(days*1440)-(hours*60) | eval minutes=floor(minutes_dec) | eval "$outField$"=case(days==1,days." day, ",days>0,days." days, ",1==1,"").case(hours=1,hours." hour, ",hours>0,hours." hours, ",1=1,"").case(minutes=1,minutes." minute",minutes>0,minutes." minutes",1==1,"").case('$inField$'==1,'$inField$'." second",'$inField$'>=0 AND '$inField$'<60,replace('$inField$',"^(\d+(\.\d)?).*$","\1")." seconds",days=0 AND hours=0 AND ('$inField$'%60)=1,", ".ceil('$inField$'%60)." second",days=0 AND hours=0 AND ('$inField$'%60)>0,", ".ceil('$inField$'%60)." seconds",1=1,"") | eval "$outField$"=rtrim(rtrim('$outField$'), ",") | fields - days,hours,minutes

[timeDiff]
definition = `timeDiff(_time)`

[hourDiff]
definition = `hourDiff(_time)`

[dayDiff]
definition = `dayDiff(_time)`

[timeDiff(1)]
args = field
definition = eval timeDiff=(time()-'$field$')

[hourDiff(1)]
args = field
definition = eval hourDiff=((time()-'$field$')/3600)

[dayDiff(1)]
args = field
definition = eval dayDiff=((time()-'$field$')/86400)

## Get events based on age in hours
[hoursago(2)]
args = num, comparator
definition = `hourDiff` | search hourDiff$comparator$$num$

## default to events less than N hours ago
[hoursago(1)]
args = num
definition = `hoursago($num$,"<")`

## Get events based on age in days
[daysago(2)]
args = num, comparator
definition = `dayDiff` | search dayDiff$comparator$$num$

## default to events less than N days ago
[daysago(1)]
args = num
definition = `daysago($num$,"<")`

## Make a timestamp from a time field with unknown format.
#  For use in converting TimeRangePicker values $search.timeRange.earliest$
#  and $search.timeRange.latest$ to timestamps if they are specified as relative
#  time modifiers.
#
# Breakdown:
# 1. If fieldIn == null(), the empty string, or whitespace, yield the value of time()
# 2. If fieldIn begins with a digit, yield the digit (assumed to be a timestamp or 0).
# 3. If fieldIn is a relative timestamp beginning with one of @, +, -, yield the converted value.
#
# Real-time qualifiers are not supported as these cannot be easily converted.
# Also, it doesn't appear to be possible to match using $ to anchor the end
# of a regex in these macros, since the $ is regarded as part of a variable expansion.
#
[make_ts_field(2)]
args = fieldIn, fieldOut
definition = eval "$fieldOut$"=case(match('$fieldIn$', "^\d"), tostring('$fieldIn$'),  match('$fieldIn$', "^([@\+-]){1}"), relative_time(time(), '$fieldIn$'),  true(), time())

[make_ts_value(2)]
args = value, fieldOut
definition = eval "$fieldOut$"=case(match("$value$", "^\d"), tostring("$value$"),  match("$value$", "^([@\+-]){1}"), relative_time(time(), "$value$"),  true(), time())

## Make the earliest and latest times that would capture the previous time-range
#  This is useful when you want to get historical information in order to
#  determine if information within a given window is higher or lower than
#  the previous window of the same size. For example, an earliest and
#  latest time range of -24h@h and now will produce a time-range of
#  -48h@h to -24h@h. The returned contents will be  a search that can be
#  used in a tstats where clause.
#
#  Breakdown:
#  1.  Make sure the search returns one row (with makeresults)
#  2.  Convert the earliest time to epoch
#  3.  Convert the latest time to epoch
#  4a. Get the size of the time-range (the difference between the earliest and latest)
#  4b. Define the latest time (previous earliest unless result is negative; then 0)
#  4c. Define the earliest time (subtract 4a from earliest unless it results in negative; then 0 earliest-time_span_diff)
#  4d. Make the search statement for the where clause
#  5.  Strip off unnecessary fields
#
[make_previous_time_range(2)]
args = earliest, latest
definition = makeresults | `make_ts_value($earliest$,earliest)` | `make_ts_value($latest$,latest)` | eval time_span_diff=latest-earliest,latest=if(round(earliest)<0,0,round(earliest)),earliest=if(round(earliest-time_span_diff)<0,0,round(earliest-time_span_diff)),search="earliest=".earliest." latest=".latest | table search

## Macro for converting TimeRangePicker values to a "between X and Y days ago" format,
#  for use when using trackers which have a firstTime, lastTime value.
[tracker_timerange_by_field(4)]
args = begin, end, firstTime, lastTime
definition = `make_ts_field($begin$, earliestQual)` | `make_ts_field($end$, latestQual)` | where ('$lastTime$'>earliestQual AND '$firstTime$'<latestQual) | fields - earliestQual, latestQual

[tracker_timerange_by_value(4)]
args = begin, end, firstTime, lastTime
definition = `make_ts_value($begin$, earliestQual)` | `make_ts_value($end$, latestQual)` | where ('$lastTime$'>earliestQual AND '$firstTime$'<latestQual) | fields - earliestQual, latestQual

# Same as previous, just shortened to use the convention firstTime, lastTime
# for field names.
[tracker_timerange_by_field(2)]
args = begin, end
definition = `tracker_timerange_by_field($begin$, $end$, firstTime, lastTime)`

[tracker_timerange_by_value(2)]
args = begin, end
definition = `tracker_timerange_by_value($begin$, $end$, firstTime, lastTime)`

## Macro for converting TimeRangePicker values to a filter suitable for inputlookup's where clause
[tracker_trp]
definition = `tracker_trp(firstTime,lastTime)`

[tracker_trp(2)]
args = begin, end
definition = [| makeresults | addinfo | eval search="$begin$>=".if(isnotnull(info_min_time),info_min_time,0).if(isnull(info_max_time) OR info_max_time="+Infinity",""," AND $end$<=".info_max_time) | return $search]

## Macro for setting time given an offset
[set_time]
definition = `set_time("-0s")`

[set_time(1)]
args = qual
definition = eval _time=relative_time(time(),"$qual$")

[time_subsearch(2)]
args = earliest,latest
definition = makeresults | eval search="_time>".floor(relative_time(time(),"$earliest$"))." _time<".floor(relative_time(time(),"$latest$")) | table search

## Get the indexer GUID from the _bkt field (SOLNESS-5985)
[get_indexer_guid]
definition = rex field=_bkt ".*~(?<indexer_guid>.+)"

[get_indexer_guid_meval]
definition = indexer_guid=replace(_bkt,".*~(.+)","\1")


#####################
## Math
#####################
[bytes2kbytes(1)]
args = field
definition = `bytes2kbytes($field$,$field$)`

[bytes2kbytes(2)]
args = inField,outField
definition = eval "$outField$"='$inField$'/1024

[bytes2mbytes(1)]
args = field
definition = `bytes2mbytes($field$,$field$)`

[bytes2mbytes(2)]
args = inField,outField
definition = eval "$outField$"='$inField$'/1048576

[bytes2gbytes(1)]
args = field
definition = `bytes2gbytes($field$,$field$)`

[bytes2gbytes(2)]
args = inField,outField
definition = eval "$outField$"='$inField$'/1073741824

## Globe distance
[globedistance(5)]
args = lat1,long1,lat2,long2,units
definition = `globedistance("distance",$lat1$,$long1$,$lat2$,$long2$,$units$,2)`

[globedistance(7)]
# The "precision" argument is numeric therefore unquoted.
args = outfield,lat1,long1,lat2,long2,units,precision
definition = eval lat1_r='$lat1$'*pi()/180 | eval lat2_r='$lat2$'*pi()/180 | eval delta=('$long2$'-'$long1$')*pi()/180 | eval R=if('$units$'="m",3959, 6372.8) | eval "$outfield$"=R*acos(sin(lat1_r)*sin(lat2_r) + cos(lat1_r) * cos(lat2_r) * cos(delta)) | eval "$outfield$"=round('$outfield$', $precision$) | fields - lat1_r,lat2_r,long1_r,long2_r,R,delta

## Standard deviation
[standard_deviations]
definition = inputlookup append=T standard_deviations

[stdev(2)]
args = intField,countField
definition = eventstats min($intField$) as min_$intField$,max($intField$) as max_$intField$,sum($countField$) as total | eventstats sum(eval($intField$*$countField$/total)) as mean_$intField$ | eventstats sum(eval(pow($intField$-mean_$intField$,2)*$countField$)) as sumsq | eval stdev=sqrt(sumsq/(total-1)) | `get_stdev_index($intField$)` | eval stdev=if(isnull(stdev),0,stdev)

## We can't single quote $Z$ at this time because of how it is invoked
## Currently we are invoking this with a negation operator
## | `stdev_desired_result(standard_deviation,mean_bytes,"gt_bytes")` | `stdev_desired_result(-standard_deviation,mean_bytes,"lt_bytes")`
[stdev_desired_result(3)]
args = Z,mean,outField
definition = eval "$outField$"=($Z$*stdev)+'$mean$'

[get_stdev_index(1)]
args = intField
definition = eval Z=(('$intField$'-'mean_$intField$')/stdev)

[get_delta]
args = 
definition = `get_delta(current_count,historical_count)`

[get_delta(2)]
args = field1,field2
definition = eval "$field1$"=if(isnum('$field1$'),'$field1$',0) | eval "$field2$"=if(isnum('$field2$'),'$field2$',0) | eval delta='$field1$'-'$field2$'


#############################
## Multivalued field handling
#############################

## Filters a value from a multi-valued field UNLESS it is the only value. 
[mvfilter_value(2)]
args = field, value
definition = eval "$field$"=if(mvcount('$field$')>1 AND '$field$'="$value$", mvfilter('$field$'!="$value$"), '$field$')

## Filters a field-value from a multi-valued field UNLESS it is the only value.
[mvfilter_field(2)]
args = field, filter_field
definition = eval `mvfilter_field_meval($field$,$filter_field$)`

[mvfilter_field_meval(2)]
args = field, filter_field
definition = "$field$"=if(mvcount('$filter_field$')=1 AND mvcount('$field$')>1 AND '$field$'='$filter_field$',split(ltrim(replace("|".mvjoin('$field$',"|"),"\|".'$filter_field$',""),"|"), "|"),'$field$')

## create a mv field from a sv field w/ default separator
[makemv(1)]
args = field
definition = `makemv($field$,"|")`

[makemv_meval(1)]
args = field
definition = `makemv_meval($field$,"|")`

## create a mv field from a sv field w/ user defined separator
[makemv(2)]
args = field, sep
definition = eval "$field$"=split('$field$',"$sep$")

[makemv_meval(2)]
args = field, sep
definition = "$field$"=split('$field$',"$sep$")

## create a sv field from a mv field w/ default separator
[makesv(1)]
args = field
definition = `makesv($field$,"|")`

## create a sv field from a mv field w/ user defined separator
[makesv(2)]
args = field, sep
definition = eval "$field$"=mvjoin('$field$',"$sep$")

## appends the values of field2 to field1
[mvappend_field(2)]
args = field1, field2
definition = eval "$field1$"=mvdedup(mvappend('$field1$',NULL,'$field2$'))

[mvappend_field_meval(2)]
args = field1, field2
definition = "$field1$"=mvdedup(mvappend('$field1$',NULL,'$field2$'))

## appends value to field
[mvappend_value(2)]
args = field, value
definition = eval "$field$"=mvdedup(mvappend('$field$',"$value$",NULL))

## appends value to field if bool==true
[mvappend_bool(3)]
args = field, value, bool
definition = eval "$field$"=if(match('$bool$', "1|[Tt]|[Tt][Rr][Uu][Ee]"),mvdedup(mvappend('$field$',"$value$",NULL)),'$field$')

[mvappend_bool_meval(3)]
args = field, value, bool
definition = "$field$"=if('$bool$'=="true",mvdedup(mvappend('$field$',"$value$",NULL)),'$field$')

## appends value to field if is_value==true
## i.e. appends "foo" to "bar" if "is_foo==true"
[mvappend_is(2)]
args = field, value
definition = `mvappend_bool($field$,$value$,"is_$value$")`

[mvappend_is_meval(2)]
args = field, value
definition = `mvappend_bool_meval($field$,$value$,"is_$value$")`

## appends should_value to field if should_value==true
## i.e. appends "should_foo" to "bar" if "should_foo==true"
[mvappend_should(2)]
args = field, value
definition = `mvappend_bool($field$,should_$value$,"should_$value$")`

[mvappend_should_meval(2)]
args = field, value
definition = `mvappend_bool_meval($field$,should_$value$,"should_$value$")`

## appends requires_value to field if requires_value==true
## i.e. appends "requires_foo" to "bar" if "requires_foo==true"
[mvappend_requires(2)]
args = field, value
definition = `mvappend_bool($field$,requires_$value$,"requires_$value$")`

[mvappend_requires_meval(2)]
args = field, value
definition = `mvappend_bool_meval($field$,requires_$value$,"requires_$value$")`

## mvdedup
## takes a multivalued field as input and creates a multivalued field containing only unique input values as output
[mvdedup(1)]
args = input
definition = `mvdedup($input$,$input$)`

[mvdedup(2)]
args = input, output
definition = eval "$output$"=mvdedup('$input$')

## mvtruncate
[mvtruncate(1)]
args = input
definition = `mvtruncate($input$,$input$,10)`

[mvtruncate(3)]
args = input, output, count
definition = eval "$output$"=if(mvcount('$input$')>$count$,mvappend(mvindex('$input$',0,$count$-1),NULL,"...truncated..."),'$input$')
errormsg = count (arg3) must be a number
validation = isnum(count)


#####################
## Integers
#####################

## 1.  Trim a number x (where x==11) of leading characters from _raw
## 1a. This is what the offset param for luhn_lookup.py does
## 2.  Pull out integer sequences based on regular expression
## 2a. Using \s and - as default separators
## 2b. For additional separators add additional "(?:\d+[<sep>]*){14,})" to the list
## 2c. {14,} defines minStrength y (where y==14)
[get_integer_seq]
definition = eval sub_raw=substr(_raw,11) | rex field=sub_raw max_match=10 "(?<integer_seq>(?:\d+[\s]*){14,}|(?:\d+[-]*){14,})"


#####################
## IP Address Utility
#####################

[ipv4_cidr_regex]
definition = "^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/(\d|[12]\d|3[012])$"


#####################
## SHC
#####################
[host_equal_local]
definition = rest splunk_server=local count=0 /services/server/info | table serverName | rename serverName as host

## 1.  Search
## 1a. Local server events only
## 1b. Internal Index
## 1c. All conf.log events
## 1d. Configuration push/pull events
## 1e. For specified configuration
## 1f. Status Applied
[shc_replication_change(1)]
args = config
definition = [| `host_equal_local`] index=_internal source=*conf.log (data.process="pullFrom" OR data.process="acceptPush") data.asset_uri{}="$config$" data.status="applied"


#####################
## Sorting
#####################
[sort_chart]
definition = `sort_chart(10)`

[sort_chart(1)]
args = head
definition = addtotals fieldname=Total | eval Total=if(isnotnull(src_port),Total-src_port,Total) | eval Total=if(isnotnull(dest_port),Total-dest_port,Total) | sort $head$ - Total | fields - Total
errormsg = head (arg1) must be an integer greater than zero
iseval = 0
validation = isint(head) AND head>0

[sort_chart(2)]
args = head, fields
definition = addtotals fieldname=Total $fields$ | sort $head$ - Total | fields - Total
errormsg = head (arg1) must be an integer greater than zero
iseval = 0
validation = isint(head) AND head>0


#####################
## Transformations
#####################

## lower
[lower(1)]
args = field1
definition = eval "$field1$"=lower('$field1$')

## namespace
[get_namespace]
definition = lookup local=true sourcetype2namespace sourcetype OUTPUT namespace

## transport_dest_port
[get_transport_dest_port]
args = 
definition = fillnull value=unknown transport | fillnull value=0 dest_port | eval transport_dest_port=transport."/".dest_port

[split_transport_dest_port(1)]
args = field
definition = rex field="$field$" "(?<transport>[^/]+)/(?<port>\d+)" | fillnull value=unknown transport | fillnull value=0 dest_port

## trim
[trim(1)]
args = field
definition = eval "$field$"=trim('$field$'," ")

## truncate
[truncate(2)]
args = field,length
definition = eval "$field$"=if(length('$field$')>$length$, substr('$field$', 0, $length$) + "...", '$field$')
errormsg = length (arg2) must be an integer greater than or equal to zero
iseval = 0
validation = isint(length) AND length>=0


#####################
## TSIDX
#####################
[tscollect(1)]
args = namespace
definition = `tscollect("$namespace$","true","false")`

[tscollect(2)]
args = namespace,squashcase
definition = `tscollect($namespace$,$squashcase$,"false")`

[tscollect(3)]
args = namespace,squashcase,keepresults
definition = tscollect namespace=$namespace$ squashcase=$squashcase$ keepresults=$keepresults$
errormsg = squashcase/keepresults (arg2/arg3) must be one of: true or false
iseval = 0
validation = (squashcase="true" OR squashcase="false") AND (keepresults="true" OR keepresults="false")

[tstats]
definition = tstats prestats=true local=`tstats_local` `summariesonly`

[tstats_local]
definition = false

## This macro has been deprecated
[allow_old_summaries_bool]
definition = true


#####################
## Users
#####################

## get_realname breakdown
## 1 - Lookup the users realname in user_realnames collection
## 2 - If the realname could not be found, use the username
[get_realname(1)]
args = user
definition = lookup update=true user_realnames_lookup user as "$user$" OUTPUTNEW realname as "$user$_realname" | eval "$user$_realname"=if(isnull('$user$_realname'),'$user$','$user$_realname')


#####################
## SA-Utils internal
#####################
[script_error_msg_ignore]
definition = (match(script, "(streamfwd|splunk-(wmi\.path|MonitorNoHandle\.exe|winevtlog\.exe|netmon\.exe|perfmon\.exe|regmon\.exe|winprintmon\.exe|admon\.exe|powershell\.exe))") AND exit_status=1) OR (script LIKE "%instrumentation.py" AND exit_status=114)

[get_dashboards_usage(3)]
args = Splunk_Role,app,Dashboard_Name
definition = lookup splunk_web_access_kv_store_lookup Splunk_Role AS $Splunk_Role$ App AS $app$ Dashboard_Name AS $Dashboard_Name$ OUTPUTNEW Earliest_Access_Updated AS Dash_Earliest_Access_Updated Latest_Access_Updated AS Dash_Latest_Access_Updated min_spent AS Dash_min_spent max_spent AS Dash_max_spent avg_spent AS Dash_avg_spent\
\
| eval Dash_Earliest_Access_Updated = strftime(Dash_Earliest_Access_Updated,"%m/%d/%Y %H:%M:%S") , Dash_Latest_Access_Updated = strftime(Dash_Latest_Access_Updated,"%m/%d/%Y %H:%M:%S")\
\
| fillnull value="Undefined" Dash_Earliest_Access_Updated Dash_Latest_Access_Updated Dash_min_spent Dash_max_spent Dash_avg_spent
iseval = 0

[get_saved_searches_usage(3)]
args = Splunk_Role,app,Savedsearch_Name
definition = lookup splunk_sh_index_internal_scheduler_jobs_kv_store_lookup Splunk_Role AS $Splunk_Role$ App AS $app$ Savedsearch_Name AS $Savedsearch_Name$ OUTPUTNEW Splunk_Instance AS Rep_Splunk_Instance User AS Rep_User Scheduled_Time AS Rep_Scheduled_Time Priority AS Rep_Priority Dispatch_Time AS Rep_Dispatch_Time Window_Time AS Rep_Window_Time Latest_Run_Time AS Rep_Latest_Run_Time Run_Time AS Rep_Run_Time Result_Count AS Rep_Result_Count\
| eval Rep_Scheduled_Time = strftime(Rep_Scheduled_Time,"%m/%d/%Y %H:%M:%S") , Rep_Dispatch_Time = strftime(Rep_Dispatch_Time,"%m/%d/%Y %H:%M:%S") , Rep_Latest_Run_Time = strftime(Rep_Latest_Run_Time,"%m/%d/%Y %H:%M:%S")\
| fillnull value="Undefined" Rep_Splunk_Instance Rep_User Rep_Scheduled_Time Rep_Priority Rep_Dispatch_Time Rep_Window_Time Rep_Latest_Run_Time Rep_Run_Time Rep_Result_Count
iseval = 0

[get_identity_info(1)]
args = username
definition = lookup update=true identity_lookup Identity as $username$ OUTPUTNEW Name,Title,Phone,Email,Emp_Type,Emp_Status,City,State,Country,Region,Location_Code,Floor_Number,startDate,endDate,Department,LOB,Cost_Center,Manager,Contractor_Expiration\
\
| fillnull value="Undefined" Name,Title,Phone,Email,Emp_Type,Emp_Status,City,State,Country,Region,Location_Code,Floor_Number,startDate,endDate,Department,LOB,Cost_Center,Manager,Contractor_Expiration
iseval = 0

[get_identity_usage(1)]
args = username
definition = lookup splunk_sh_index_audit_user_login_kv_store_lookup User AS $username$ OUTPUTNEW Earliest_Login_Updated AS User_Earliest_Login_Updated Latest_Login_Updated AS User_Latest_Login_Updated Splunk_Role AS User_Splunk_Role Login_Source AS User_Login_Source\
\
| eval User_Earliest_Login_Updated = strftime(User_Earliest_Login_Updated,"%m/%d/%Y %H:%M:%S") , User_Latest_Login_Updated = strftime(User_Latest_Login_Updated,"%m/%d/%Y %H:%M:%S")\
\
| fillnull value="Undefined" User_Earliest_Login_Updated User_Latest_Login_Updated User_Splunk_Role User_Login_Source
iseval = 0

[get_field_desc(1)]
args = Field_Name
definition = lookup splunk_fields_lookup Field_Name AS $Field_Name$ OUTPUTNEW Field_Description
iseval = 0

[get_lookup_reference(1)]
args = field
definition = rex field=$field$ max_match=0 "\|\s*lookup\s*(?<Lookup_Reference1>\w+)" \
| rex field=$field$ max_match=0 "\|\s*(input|output)lookup\s*(append=\w+\s+)?(?<Lookup_Reference2>\w+)" \
| rex field=$field$ max_match=0 "from\s+lookup:(?<Lookup_Reference3>\w+)" \
| eval Lookup_Reference=mvsort(mvdedup(mvappend(Lookup_Reference1, Lookup_Reference2, Lookup_Reference3)))\
\
| fillnull value="Undefined" Lookup_Reference
iseval = 0

[get_saved_searches_info(1)]
args = Savedsearch_Name
definition = lookup shc_saved_searches_rest_kv_store_lookup savedsearch_name AS $Savedsearch_Name$ OUTPUTNEW description savedsearch_type cron_schedule scheduled_times next_scheduled_time auto_summarize dispatch_earliest_time dispatch_latest_time schedule_priority max_concurrent schedule_window allow_skew realtime_schedule alert_severity alert_track alert_type removable run_n_times run_on_startup Lookup_Reference Datamodel_Reference search \
\
| fillnull value="Undefined" description savedsearch_type cron_schedule scheduled_times next_scheduled_time auto_summarize dispatch_earliest_time dispatch_latest_time schedule_priority max_concurrent schedule_window allow_skew realtime_schedule alert_severity alert_track alert_type removable run_n_times run_on_startup Lookup_Reference Datamodel_Reference search
iseval = 0

[get_splunk_env(1)]
args = host
definition = eval $host$=upper($host$) \
| lookup splunk_assets_lookup host AS $host$ OUTPUT Splunk_Role AS Splunk_Role\
| fillnull value="Unknown" Splunk_Role
iseval = 0

[normalize_search_id(1)]
args = search_id
definition = rex field=$search_id$ "_(?<search_id_normalized1>\d+[._]\d+)_" \
| rex field=$search_id$ "(?<search_id_normalized2>\d+[._]\d+$)" \
| rex field=$search_id$ "(?<search_id_normalized3>^\d+[._]\d+)" \
| eval search_id_normalized = if(isnull(search_id_normalized1), search_id_normalized2, search_id_normalized1) \
| eval search_id_normalized = if(isnull(search_id_normalized), search_id_normalized3, search_id_normalized) \
| eval search_id_normalized = if(isnull(search_id_normalized), search_id, search_id_normalized)\
| rex field=search_id_normalized mode=sed "s/\./_/g"\
| rex field=search_id_normalized mode=sed "s/^\w+;\w+;//g"\
| fields - search_id_normalized1, search_id_normalized2, search_id_normalized3
iseval = 0

[gmc_time_format(1)]
args = time
definition = $time$ = strftime($time$, "%m/%d/%Y %H:%M:%S")
iseval = 0

[rename_common_fields]
definition = rename host as Host , search_id as "Search ID" , search_id_normalized as "Normalized Search ID" , user as User , search_type as "Search Type" , savedsearch_name as "Savedsearch Name" , 'total_run_time' as Runtime, total_run_time as Runtime_Sec , info as Info
iseval = 0

[get_dm_field(2)]
args = dataset,field
definition = tstats SUMMARIESONLY=TRUE ALLOW_OLD_SUMMARIES=FALSE \
    count\
    FROM DATAMODEL=Splunk_Search_Logs\
    WHERE nodename=Search_Activity.$dataset$\
    BY Search_Activity.$dataset$.$field$\
| `drop_dm_object_name(Search_Activity.$dataset$)`\
| table $field$ count
iseval = 0

[splunk_default_vs_custom_roles]
definition = eval type=if(match(title, "^(?:admin|can_delete|power|splunk-system-role|user|ess_admin|ess_analyst|ess_user)$"), "default", "custom")
iseval = 0

[mvcount_zero(2)]
args = field, pattern
definition = if(isnull(mvcount(mvfilter(match($field$,$pattern$)))),0,mvcount(mvfilter(match($field$,$pattern$))))
iseval = 0

[compute_accessible_index_count]
definition = case(\
       isnotnull(mvfind(srchIndexesAllowed,"^_\*$")) AND isnotnull(mvfind(srchIndexesAllowed,"^\*$")), 'c_non-internal'+'c_internal',\
       isnotnull(mvfind(srchIndexesAllowed,"^\*$")), 'c_non-internal' + `mvcount_zero(srchIndexesAllowed, \"^_[^\*]+$\")`,\
       isnotnull(mvfind(srchIndexesAllowed,"^_\*$")), 'c_internal' + `mvcount_zero(srchIndexesAllowed, \"^[^_]+$\")`,\
       srchIndexesAllowed == "", 0,\
       isnull(mvfind(srchIndexesAllowed,"^_\*$")) AND isnull(mvfind(srchIndexesAllowed,"^\*$")), mvcount(srchIndexesAllowed)\
  )
iseval = 0

[prettyIndexNotation(1)]
args = field
definition = rex field=$field$ mode=sed "s/_\*/All internal indexes/g"  | rex field=$field$ mode=sed "s/\*/All non-internal indexes/g"
iseval = 0

[prettymv(1)]
args = field
definition = eval $field$=mvjoin($field$, ", ")
iseval = 0

[prettyRoleNotation(1)]
args = field
definition = rex field=$field$ mode=sed "s/\*/All roles/g"
iseval = 0

[compute_user_to_indexes]
definition = rest splunk_server=local /services/authentication/users | `prettymv(roles)` | fields title, roles | rename title AS username\
\
| makemv delim=", " roles | mvexpand roles | rename roles AS role | join role [| rest splunk_server=local /services/authorization/roles |  rename title AS role | fillnull value="" | fields role, srchIndexesAllowed]\
| fields username, srchIndexesAllowed \
\
| rex field=srchIndexesAllowed mode=sed "s/\s/,/g" \
| makemv delim="," srchIndexesAllowed \
| mvcombine srchIndexesAllowed | mvcombine srchIndexesAllowed | rex field=srchIndexesAllowed mode=sed "s/\s/,/g" | makemv delim="," srchIndexesAllowed | eventstats values(srchIndexesAllowed) AS didx by username | fields username, didx | mvcombine didx | rex field=didx mode=sed "s/\s/, /g"\
| rename didx AS accessible_indexes
iseval = 0

[indexes_to_counts(1)]
args = indexes
definition = join  [| rest splunk_server=local /services/data/indexes | fields title | eval type=if(match(title,"^_\w+$"),"c_internal","c_non-internal") | eval x="woot" | stats count by type, x | xyseries x type count | fields - x]  \
\
| makemv delim=", " $indexes$ | rename $indexes$ AS srchIndexesAllowed\
| eval totalAccess = `compute_accessible_index_count` | fillnull value="noidea" totalAccess | fields - c_*\
| rename srchIndexesAllowed AS accessible_indexes\
| mvcombine accessible_indexes
iseval = 0

[splunk_default_vs_custom_indexes]
definition = eval type=if(match(title, "^(?:main|summary|_\w+)$"), "default", "custom")
iseval = 0

[compute_indexes_to_roles_and_users]
definition = `compute_user_to_indexes` \
| join username [| rest splunk_server=local /services/authentication/users | `prettymv(roles)` | rename title AS username| fields username, roles] \
| makemv delim=", " accessible_indexes | mvexpand accessible_indexes\
| join accessible_indexes type=outer [| rest /services/data/indexes | fields title | dedup title | where match(title, "^_\w+$") | mvcombine title | `prettymv(title)` | rename title AS expanded_indexes | eval accessible_indexes="_*"] \
| join accessible_indexes type=outer [| rest /services/data/indexes | fields title | dedup title | where match(title, "^[^_]+$") | mvcombine title | `prettymv(title)` | rename title AS expanded_indexes | eval accessible_indexes="*"]\
\
| eval accessible_indexes=if(match(accessible_indexes, "^(?:_\*|\*)$"), expanded_indexes, accessible_indexes) | fields - expanded_indexes\
| makemv delim=", " accessible_indexes | mvexpand accessible_indexes \
| makemv delim=", " roles | mvexpand roles \
| stats values(roles) AS roles values(username) AS users by accessible_indexes\
\
| rename accessible_indexes AS index\
\
| `prettymv(roles)` | `prettymv(users)` | eval user_count=mvcount(split(users, ", ")) | eval role_count=mvcount(split(roles, ", "))
iseval = 0

[compute_capabilities_to_roles]
definition = join capability type=outer [| rest splunk_server=local /services/authentication/users | fields roles, capabilities\
| mvexpand capabilities | mvcombine roles | mvcombine roles\
| rex field=roles mode=sed "s/\s/, /g"\
| makemv delim=", " roles | eventstats values(roles) AS roles by capabilities | eval role_count=mvcount(roles)\
| `prettymv(roles)` | rename capabilities AS capability] | fillnull value=0 role_count
iseval = 0

[compute_capabilities_to_users]
definition = join capability type=outer [| rest splunk_server=local /services/authentication/users | fields title, capabilities | rename title AS username\
| mvexpand capabilities | mvcombine username \
| eval user_count=mvcount(username)\
| `prettymv(username)` | rename username AS users capabilities AS capability] | fillnull value=0 user_count
iseval = 0

[splunk_internal_apps]
definition = eval isInternalApp=if(match(label, "^(?:SplunkForwarder| SplunkLightForwarder|Splunk Data Preview|Search & Reporting|sample data|SA-Eventgen|legacy|learned|Home|Getting started)$"), 1, 0)\

iseval = 0

[prettybool(1)]
args = field
definition = eval $field$=if($field$==1, "yes", "no")
iseval = 0

[splunk_classify_apps]
definition = `splunk_internal_apps` | eval app_source=case(isInternalApp==1, "internal", isnull(details), "custom", isInternalApp==0, "apps.splunk.com")\
| fields - isInternalApp
iseval = 0

[prettyUserNotation(1)]
args = field
definition = rex field=$field$ mode=sed "s/\*/All users/g"
iseval = 0

[convert_delims_space2spacecomma(1)]
args = field
definition = rex field=$field$ mode=sed "s/\s/, /g"
iseval = 0

[compute_apps_to_users_and_roles]
definition = rest splunk_server=local /services/apps/local/ | fields title, eai:acl.perms.read, eai:acl.perms.write\
\
| rename title AS app eai:acl.perms.read AS read eai:acl.perms.write AS write\
| mvexpand read | mvexpand write\
\
| join type=outer read  [| rest splunk_server=local /services/authentication/users | fields title, roles | mvexpand roles | rename title AS user_read roles AS read | mvcombine user_read]\
| join type=outer write  [| rest splunk_server=local /services/authentication/users | fields title, roles | mvexpand roles | rename title AS user_write roles AS write | mvcombine user_write]\
\
| eval user_read=if(match(read, "^\*$"), "*", user_read)\
| eval user_write=if(match(write, "^\*$"), "*", user_write)\
\
| stats values(read) AS roles_read values(user_read) AS users_read values(write) AS roles_write values(user_write) AS users_write by app \
| mvcombine roles_read | mvcombine roles_write | mvcombine users_read | mvcombine users_write\
\
| eval orig_roles_read = roles_read\
| eval orig_roles_write = roles_write\
| eval orig_users_read = users_read\
| eval orig_users_write = users_write\
\
| eval x=1 \
| join x [ |rest splunk_server=local /services/authentication/users | stats values(title) AS all_users count AS user_count | eval x=1] | join x [ |rest splunk_server=local /services/authorization/roles | stats values(title) AS all_roles count AS role_count | eval x=1] \
| fields - x\
\
| eval roles_read=if(match(roles_read, "^\*$"), all_roles, roles_read)\
| eval roles_write=if(match(roles_write, "^\*$"), all_roles, roles_write)\
| eval users_read=if(match(users_read, "^\*$"), all_users, users_read)\
| eval users_write=if(match(users_write, "^\*$"), all_users, users_write)\
| fields - all_roles all_users\
\
| `convert_all_delims_space2spacecomma(roles_* users_* orig_*)`\
\
| eval role_read_count=if(match(orig_roles_read, "^\*$"), role_count, mvcount(split(roles_read, ", ")))\
| eval user_read_count=if(match(orig_users_read, "^\*$"), user_count, mvcount(split(users_read, ", "))) \
| eval role_write_count=if(match(orig_roles_write, "^\*$"), role_count, mvcount(split(roles_write, ", ")))\
| eval user_write_count=if(match(orig_users_write, "^\*$"), user_count, mvcount(split(users_write, ", ")))\

iseval = 0

[convert_all_delims_space2spacecomma(1)]
args = fields
definition = foreach $fields$ [`convert_delims_space2spacecomma(<<FIELD>>)`]
iseval = 0

[prettyObjectDetails]
definition = fields eai:acl.app, title, eai:acl.sharing, eai:acl.perms.read, eai:acl.perms.write\
| rename eai:acl.app AS app, eai:acl.sharing AS sharing, eai:acl.perms.read AS "read", eai:acl.perms.write AS "write"\
| `prettyRoleNotation(read)` | `prettyRoleNotation(write)`\
\
| eval sharing=if(sharing=="user","private", sharing)\
| eval read=if(sharing=="private", "Private", read)\
| eval write=if(sharing=="private", "Private", write)\
| fillnull value="admin" read write\
| `prettymv(read)` | `prettymv(write)`\
| rename read AS "read roles" write AS "write roles" sharing AS "sharing context"
iseval = 0

[compute_user_executed_searches(1)]
args = user
definition = index=_audit action=search (id=* OR search_id=*) user="$user$"\
                  | eval search_id=if(isnull(search_id), id, search_id)\
                  | replace '*' with * in search_id\
                  | search search_id!=rt_* search_id!=searchparsetmp*\
                  | rex "search='(?<search>.*?)', autojoin"\
                  | rex "savedsearch_name=\"(?<savedsearch_name>.*?)\"\]\["\
                  |  eval search=case(isnotnull(search),search,isnull(search) AND savedsearch_name!="","Scheduled search name : ".savedsearch_name,isnull(search) AND savedsearch_name=="","SID : ".search_id)\
                  |  eval user = if(user="n/a", "nobody", user)\
                  | stats min(_time) as _time last(user) as user last(search) as search by search_id | search search_id=* search!=typeahead* search!="|history*" search!=*_internal* search!=*_audit*\
\
| search search_id!=subsearch_* | stats count values(user) as User(s) by search | sort 50 - count | fields count User(s) search
iseval = 0

[search_manager_app_overview_app_to_roles]
definition = `compute_apps_to_users_and_roles` | join app [| rest splunk_server=local /services/apps/local | rename title AS app | fields app, disabled, visible] | rename roles_read AS role | search $role_app$ AND * | fields app, role | makemv delim=", " role | mvexpand role | stats count by app, role | search *
iseval = 0

[search_manager_app_overview_app_to_roles(4)]
args = type, app, roles, state
definition = `compute_apps_to_users_and_roles` | join app [| rest splunk_server=local /services/apps/local | rename title AS app | fields app, disabled, visible] | rename roles_read AS role | search $roles$ AND $state$ | fields app, role | makemv delim=", " role | mvexpand role | stats count by app, role | search app
iseval = 0

[compute_environment_detail_counts]
definition = rest splunk_server=local /servicesNS/-/-/saved/searches | stats count AS savedsearches, sum(action.email) AS alerts, sum(is_scheduled) AS scheduledsearches,  sum(auto_summarize) AS ra\
| appendcols [| rest splunk_server=local /servicesNS/-/-/datamodel/model | stats count AS datamodels]\
| appendcols [| rest splunk_server=local /servicesNS/-/-/data/ui/views | stats count AS dashboards]\
| appendcols [| rest splunk_server=local /services/apps/local | stats count AS apps]\
\
| appendcols [| rest splunk_server=local /services/authentication/users | stats count AS users]\
| appendcols [| rest splunk_server=local /services/authorization/roles | stats count AS roles]\
\
| appendcols [| metadata type=sources | stats count AS sources]\
| appendcols [| metadata type=sourcetypes | stats count AS sourcetypes]\
| appendcols [| metadata type=hosts | stats count AS hosts]\
| appendcols [| rest splunk_server=local /services/data/indexes | stats count as indexes]\
\
| eval search_name="governance_system_details"
iseval = 0

[get_environment_detail_counts]
definition = `compute_environment_detail_counts` | eval _time=now()\
| append [search index=summary search_name=governance_system_details | fields savedsearches, alerts, scheduledsearches, ra, apps, dashboards, datamodels, hosts, indexes, roles, search_name, sources, sourcetypes, users | fields - _raw]\
| fields - search_name
iseval = 0

[special_names]
definition = "Aaron Kornhauser, Mike Barrie, Sanford Owings"
iseval = 0

[parse_btool_output]
definition = multikv noheader=true | rename Column_1 AS file Column_2 AS setting | rex "^(?<file>\S+)\s+" | rex "\s+(?=[^\[])(?<key>\S+)\s*=\s*(?<value>.*)$"
iseval = 0

[search_perf_flags]
definition = eval flags=mvappend(flags, if(match(search, "(?i)\|\s*join"), "Join", null())) \
| eval flags=mvappend(flags, if(match(search, "(?i)\|\s*append"), "Append*", null())) \
| eval flags=mvappend(flags, case(log(scan_count) > (log(event_count) + 3), "BigO3", log(scan_count) > (log(event_count) + 2), "BigO2", log(scan_count) > (log(event_count) + 1), "BigO", 1=1, null())) \
| eval commands=commands(search)| eval first_phrase=if(mvindex(commands, 0) != "search", "generating", replace(search, "^([^\|]+)", "\1")) \
| eval flags=mvappend(flags, case(first_phrase="generating", null(), 1=1 AND NOT match(first_phrase, "\s*index\s*=\s*"), "No idx", 1=1 AND NOT match(first_phrase, "\ssourcetype\s*=\s*"), "No st", 1=1, null())) \
| eval flags=mvappend(flags, if(result_count > 1000, "Mach5", null()))

[get_audit_index]
definition = index=_audit
