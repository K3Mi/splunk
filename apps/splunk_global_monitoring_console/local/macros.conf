[Search_Head_Cluster]
definition = host IN (123)
iseval = 0

[Splunk_Heavy_Forwarders]
definition = hostname IN (123)
iseval = 0

[Indexer_Cluster]
definition = host IN (123)
iseval = 0

[Search_Heads]
definition = host IN (123)
iseval = 0

[Splunk_Role]
definition = eval Splunk_Role = case ( \
    match(search_group, "PROD-IDXC-1$") OR match(host, "^\w+-SPLN?K-IN?DX\d+"), "PROD-IDXC-1", \
    match(search_group, "PROD-IDXC-2$"), "PROD-IDXC-2",\
    match(search_group, "PROD-CM-1$") OR match(host, "123"), "PROD-CM-1", \
    match(search_group, "PROD-CM-2$") OR match(host, "123"), "PROD-CM-2", \
    match(search_group, "PROD-HF-1$"), "PROD-HF-1",\
    match(search_group, "PROD-LM-1$") OR match(host, "123"), "PROD-LM-1",\
    match(search_group, "PROD-MC-1$"), "PROD-MC-1",\
    match(search_group, "PROD-MC-2$"), "PROD-MC-2",\
    match(search_group, "PROD-SH$"), "PROD-SH",\
    match(search_group, "PROD-SHC-1$"), "PROD-SHC-1",\
    match(search_group, "PROD-SHC-2$"), "PROD-SHC-2", \
    match(search_group, "PROD-SHC-DP-1$"), "PROD-SHC-DP-1", \
    match(search_group, "PROD-SHC-DP-2$"), "PROD-SHC-DP-2", \
    match(search_group, "PROD-DS-1$"), "PROD-DS-1",\
    match(search_group, "PROD-DS-2$") OR match(host, "123"), "PROD-DS-2",\
    match(search_group, "PROD-ITSI-1$") OR match(host, "123|123|123"), "PROD-ITSI-1", \
    match(search_group, "UAT-CM-1$"), "UAT-CM-1", \
    match(search_group, "UAT-HF-1$"), "UAT-HF-1", \
    match(search_group, "UAT-IDXC-1$"), "UAT-IDXC-1",\
    match(search_group, "UAT-SHC-1$") OR match(host, "123"), "UAT-SHC-1",\
    match(search_group, "UAT-HF-1$") OR match(host, "123|123|123|123|123|123|123"), "UAT-HF-1",\
    match(search_group, "DEV-SHC-1$") OR match(host, "123|123|123"), "DEV-SHC-1",\
    match(search_group, "DEV-IDXC-1$"), "DEV-IDXC-1",\
    match(search_group, "DEV-CM-1$") OR match(host, "123"), "DEV-CM-1",\
    match(search_group, "DEV-DS-1$"), "DEV-DS-1",\
    match(search_group, "DEV-LM-1$"), "DEV-LM-1",\
    true(), null() ) \
| eval host_lookup = if ( isnull(Splunk_Role), lower(host), null() ) \
| lookup dmc_assets host AS host_lookup OUTPUT search_group AS search_group_lookup \
| eval search_group_lookup = mvfilter ( match (search_group_lookup, "^dmc_customgroup_") ) \
| rex field=search_group_lookup mode=sed "s/^dmc_customgroup_//g" \
| eval Splunk_Role = mvappend (Splunk_Role, search_group_lookup)\
| fields - host_lookup search_group_lookup
iseval = 0
disabled = 1

[cron_schedule(1)]
args = cron_schedule
definition = rex field=$cron_schedule$ "(?<Minute>^.*?)\\s(?<Hour>.*?)\\s(?<Day_of_Month>.*?)\\s(?<Month>.*?)\\s(?<Day_of_Week>.*?)$" \
| eval \
    Minute = case ( \
    (Minute == "*"),"Any", \
    true(), Minute ), \
    Hour = if ( match(Hour,"^\\*"),"Any",Hour ),\
    Day_of_Week = case ( \
    (Day_of_Week == 0 OR Day_of_Week == 7),"Sunday", \
    (Day_of_Week == 1), "Monday",\
    (Day_of_Week == 2), "Tuesday",\
    (Day_of_Week == 3), "Wednesday",\
    (Day_of_Week == 4), "Thursday",\
    (Day_of_Week == 5), "Friday",\
    (Day_of_Week == 6), "Saturday", \
    (Day_of_Week == "*"),"Any", \
    true(), Day_of_Week),\
    Day_of_Month = if ( match(Day_of_Month,"^\\*"), "Any", Day_of_Month), \
    Month = case ( \
    (Month == 1),"January",\
    (Month == 2),"February",\
    (Month == 3),"March",\
    (Month == 4),"April",\
    (Month == 5),"May",\
    (Month == 6),"June",\
    (Month == 7),"July",\
    (Month == 8),"August",\
    (Month == 9),"September",\
    (Month == 10),"October",\
    (Month == 11),"November",\
    (Month == 12),"December", \
    (Month == "*"),"Any", \
    true(), Month ), \
    Cron_Schedule_translated=((((((((("Minute: " . Minute) . " | Hour: ") . Hour) . " | Day_of_Month: ") . Day_of_Month) . " | Month: ") . Month) . " | Day_of_Week: ") . Day_of_Week)\
| fields - Minute, Hour, Day_of_Month, Month, Day_of_Week
iseval = 0

[gmc_convert_runtime(1)]
args = runtime
definition = eval $runtime$ = case( \
round($runtime$ / (3600*24) - 0.5) > 0, round($runtime$ / (3600*24) - 0.5)."d ".round(($runtime$ % (3600*24)) / 3600 - 0.5)."h ".round(($runtime$ % 3600) / 60 - 0.5)."min ".round($runtime$ % 60, 2)."s", \
round(($runtime$ % (3600*24)) / 3600 - 0.5) > 0, round(($runtime$ % (3600*24)) / 3600 - 0.5)."h ".round(($runtime$ % 3600) / 60 - 0.5)."min ".round($runtime$ % 60, 2)."s", \
round(($runtime$ % 3600) / 60 - 0.5) > 0, round(($runtime$ % 3600) / 60 - 0.5)."min ".round($runtime$ % 60, 2)."s", \
1 = 1, round($runtime$ % 60, 2)."s" \
)
iseval = 0

[get_saved_searches_info(3)]
args = Splunk_Role,App,Savedsearch_Name
definition = lookup shc_saved_searches_rest_kv_store_lookup Splunk_Role AS $Splunk_Role$ app AS $App$ savedsearch_name AS $Savedsearch_Name$ OUTPUTNEW description savedsearch_type sharing author owner updated disabled is_visible is_scheduled cron_schedule scheduled_times next_scheduled_time dc_scheduled_times auto_summarize dispatch_earliest_time dispatch_latest_time schedule_priority max_concurrent schedule_window allow_skew realtime_schedule alert_severity alert_track alert_type removable run_n_times run_on_startup Lookup_Reference Datamodel_Reference search \
| fillnull value="Undefined" description savedsearch_type sharing author owner updated disabled is_visible is_scheduled cron_schedule scheduled_times next_scheduled_time dc_scheduled_times auto_summarize dispatch_earliest_time dispatch_latest_time schedule_priority max_concurrent schedule_window allow_skew realtime_schedule alert_severity alert_track alert_type removable run_n_times run_on_startup Lookup_Reference Datamodel_Reference search
iseval = 0

[get_saved_searches_info(2)]
args = App,Savedsearch_Name
definition = lookup shc_saved_searches_rest_kv_store_lookup app AS $App$ savedsearch_name AS $Savedsearch_Name$ OUTPUTNEW description savedsearch_type sharing author owner updated disabled is_visible is_scheduled cron_schedule scheduled_times next_scheduled_time dc_scheduled_times auto_summarize dispatch_earliest_time dispatch_latest_time schedule_priority max_concurrent schedule_window allow_skew realtime_schedule alert_severity alert_track alert_type removable run_n_times run_on_startup Lookup_Reference Datamodel_Reference search \
| fillnull value="Undefined" description savedsearch_type sharing author owner updated disabled is_visible is_scheduled cron_schedule scheduled_times next_scheduled_time dc_scheduled_times auto_summarize dispatch_earliest_time dispatch_latest_time schedule_priority max_concurrent schedule_window allow_skew realtime_schedule alert_severity alert_track alert_type removable run_n_times run_on_startup Lookup_Reference Datamodel_Reference search
iseval = 0

[get_dashboards_info(2)]
args = App,Title
definition = lookup splunk_sh_rest_data_ui_dashboards_lookup app AS $App$ title AS $Title$ OUTPUTNEW sharing title label description type dashboard_size author location removable updated data Report_Reference Dashboard_Reference Lookup_Reference Datamodel_Reference Search BaseSearch \
| fillnull value="Undefined" sharing title label description type dashboard_size author location removable updated data Report_Reference Dashboard_Reference Lookup_Reference Datamodel_Reference Search BaseSearch
iseval = 0



# From SA-Utils

#####################
## Boolean
#####################

## str_to_bool
[str_to_bool(1)]
args = field
definition = `str_to_bool($field$,$field$)`

[str_to_bool_meval(1)]
args = field
definition = `str_to_bool_meval($field$,$field$)`

[str_to_bool(2)]
args = inField,outField
definition = eval `str_to_bool_meval($inField$,$outField$)`

[str_to_bool_meval(2)]
args = inField,outField
definition = "$outField$"=case(match('$inField$', "1|[Tt]|[Tt][Rr][Uu][Ee]"),"true",match('$inField$', "0|[Ff]|[Ff][Aa][Ll][Ss][Ee]"),"false",1=1,'$inField$')


#####################
## Charting
#####################
[autopause]
definition = 120

[round(1)]
args = field
definition = `round("$field$",2)`

[round(2)]
args = field,precision
definition = `round("$field$","$field$",$precision$)`

[round(3)]
args = inField,outField,precision
definition = eval "$outField$"=round('$inField$',$precision$)
errormsg = precision (arg3) must be an integer greater than zero
iseval = 0
validation = isint(precision) AND precision>0

[wrap(2)]
args = field,length
definition = rex field="$field$" max_match=0 "(?<$field$>.{1,$length$})"
errormsg = length (arg2) must be an integer greater than zero
iseval = 0
validation = isint(length) AND length>0


#####################
## Date/Time
#####################

## create simple date field
[get_date(1)]
args = field
definition = eval date='$field$' | `ctime(date,"%m-%d-%Y")`

## convert epoch time to string
[ctime(1)]
args = field
definition = `ctime($field$,"%m/%d/%Y %H:%M:%S")`

## convert epoch time to string w/ format
[ctime(2)]
args = field,format
definition = convert timeformat="$format$" ctime($field$)

[ctime(3)]
args = inField,outField,format
definition = `ctime($inField$,"$format$")` as $outField$

## convert string to epoch time
[mktime(1)]
args = field
definition = `mktime($field$,"%m/%d/%Y %H:%M:%S")`

## convert string w/ format to epoch time
[mktime(2)]
args = field,format
definition = convert timeformat="$format$" mktime($field$)

[mktime(3)]
args = inField,outField,format
definition = `mktime($inField$,"$format$")` as $outField$

## format epoch time
[uitime(1)]
args = field
definition = `uitime($field$,"%m/%d/%Y %H:%M:%S")`

## format epoch time w/ format
[uitime(2)]
args = field,format
definition = fieldformat "$field$"=strftime('$field$', "$format$")

## convert uptime (# secs) to string
[uptime2string(2)]
args = inField,outField
definition = eval days_dec='$inField$'/86400 | eval days=floor(days_dec) | eval hours_dec=('$inField$'/3600)-(days*24) | eval hours=floor(hours_dec) | eval minutes_dec=('$inField$'/60)-(days*1440)-(hours*60) | eval minutes=floor(minutes_dec) | eval "$outField$"=case(days==1,days." day, ",days>0,days." days, ",1==1,"").case(hours=1,hours." hour, ",hours>0,hours." hours, ",1=1,"").case(minutes=1,minutes." minute",minutes>0,minutes." minutes",1==1,"").case('$inField$'==1,'$inField$'." second",'$inField$'>=0 AND '$inField$'<60,replace('$inField$',"^(\d+(\.\d)?).*$","\1")." seconds",days=0 AND hours=0 AND ('$inField$'%60)=1,", ".ceil('$inField$'%60)." second",days=0 AND hours=0 AND ('$inField$'%60)>0,", ".ceil('$inField$'%60)." seconds",1=1,"") | eval "$outField$"=rtrim(rtrim('$outField$'), ",") | fields - days,hours,minutes

[timeDiff]
definition = `timeDiff(_time)`

[hourDiff]
definition = `hourDiff(_time)`

[dayDiff]
definition = `dayDiff(_time)`

[timeDiff(1)]
args = field
definition = eval timeDiff=(time()-'$field$')

[hourDiff(1)]
args = field
definition = eval hourDiff=((time()-'$field$')/3600)

[dayDiff(1)]
args = field
definition = eval dayDiff=((time()-'$field$')/86400)

## Get events based on age in hours
[hoursago(2)]
args = num, comparator
definition = `hourDiff` | search hourDiff$comparator$$num$

## default to events less than N hours ago
[hoursago(1)]
args = num
definition = `hoursago($num$,"<")`

## Get events based on age in days
[daysago(2)]
args = num, comparator
definition = `dayDiff` | search dayDiff$comparator$$num$

## default to events less than N days ago
[daysago(1)]
args = num
definition = `daysago($num$,"<")`

## Make a timestamp from a time field with unknown format.
#  For use in converting TimeRangePicker values $search.timeRange.earliest$
#  and $search.timeRange.latest$ to timestamps if they are specified as relative
#  time modifiers.
#
# Breakdown:
# 1. If fieldIn == null(), the empty string, or whitespace, yield the value of time()
# 2. If fieldIn begins with a digit, yield the digit (assumed to be a timestamp or 0).
# 3. If fieldIn is a relative timestamp beginning with one of @, +, -, yield the converted value.
#
# Real-time qualifiers are not supported as these cannot be easily converted.
# Also, it doesn't appear to be possible to match using $ to anchor the end
# of a regex in these macros, since the $ is regarded as part of a variable expansion.
#
[make_ts_field(2)]
args = fieldIn, fieldOut
definition = eval "$fieldOut$"=case(match('$fieldIn$', "^\d"), tostring('$fieldIn$'),  match('$fieldIn$', "^([@\+-]){1}"), relative_time(time(), '$fieldIn$'),  true(), time())

[make_ts_value(2)]
args = value, fieldOut
definition = eval "$fieldOut$"=case(match("$value$", "^\d"), tostring("$value$"),  match("$value$", "^([@\+-]){1}"), relative_time(time(), "$value$"),  true(), time())

## Make the earliest and latest times that would capture the previous time-range
#  This is useful when you want to get historical information in order to
#  determine if information within a given window is higher or lower than
#  the previous window of the same size. For example, an earliest and
#  latest time range of -24h@h and now will produce a time-range of
#  -48h@h to -24h@h. The returned contents will be  a search that can be
#  used in a tstats where clause.
#
#  Breakdown:
#  1.  Make sure the search returns one row (with makeresults)
#  2.  Convert the earliest time to epoch
#  3.  Convert the latest time to epoch
#  4a. Get the size of the time-range (the difference between the earliest and latest)
#  4b. Define the latest time (previous earliest unless result is negative; then 0)
#  4c. Define the earliest time (subtract 4a from earliest unless it results in negative; then 0 earliest-time_span_diff)
#  4d. Make the search statement for the where clause
#  5.  Strip off unnecessary fields
#
[make_previous_time_range(2)]
args = earliest, latest
definition = makeresults | `make_ts_value($earliest$,earliest)` | `make_ts_value($latest$,latest)` | eval time_span_diff=latest-earliest,latest=if(round(earliest)<0,0,round(earliest)),earliest=if(round(earliest-time_span_diff)<0,0,round(earliest-time_span_diff)),search="earliest=".earliest." latest=".latest | table search

## Macro for converting TimeRangePicker values to a "between X and Y days ago" format,
#  for use when using trackers which have a firstTime, lastTime value.
[tracker_timerange_by_field(4)]
args = begin, end, firstTime, lastTime
definition = `make_ts_field($begin$, earliestQual)` | `make_ts_field($end$, latestQual)` | where ('$lastTime$'>earliestQual AND '$firstTime$'<latestQual) | fields - earliestQual, latestQual

[tracker_timerange_by_value(4)]
args = begin, end, firstTime, lastTime
definition = `make_ts_value($begin$, earliestQual)` | `make_ts_value($end$, latestQual)` | where ('$lastTime$'>earliestQual AND '$firstTime$'<latestQual) | fields - earliestQual, latestQual

# Same as previous, just shortened to use the convention firstTime, lastTime
# for field names.
[tracker_timerange_by_field(2)]
args = begin, end
definition = `tracker_timerange_by_field($begin$, $end$, firstTime, lastTime)`

[tracker_timerange_by_value(2)]
args = begin, end
definition = `tracker_timerange_by_value($begin$, $end$, firstTime, lastTime)`

## Macro for converting TimeRangePicker values to a filter suitable for inputlookup's where clause
[tracker_trp]
definition = `tracker_trp(firstTime,lastTime)`

[tracker_trp(2)]
args = begin, end
definition = [| makeresults | addinfo | eval search="$begin$>=".if(isnotnull(info_min_time),info_min_time,0).if(isnull(info_max_time) OR info_max_time="+Infinity",""," AND $end$<=".info_max_time) | return $search]

## Macro for setting time given an offset
[set_time]
definition = `set_time("-0s")`

[set_time(1)]
args = qual
definition = eval _time=relative_time(time(),"$qual$")

[time_subsearch(2)]
args = earliest,latest
definition = makeresults | eval search="_time>".floor(relative_time(time(),"$earliest$"))." _time<".floor(relative_time(time(),"$latest$")) | table search

## Get the indexer GUID from the _bkt field (SOLNESS-5985)
[get_indexer_guid]
definition = rex field=_bkt ".*~(?<indexer_guid>.+)"

[get_indexer_guid_meval]
definition = indexer_guid=replace(_bkt,".*~(.+)","\1")


#####################
## Math
#####################
[bytes2kbytes(1)]
args = field
definition = `bytes2kbytes($field$,$field$)`

[bytes2kbytes(2)]
args = inField,outField
definition = eval "$outField$"='$inField$'/1024

[bytes2mbytes(1)]
args = field
definition = `bytes2mbytes($field$,$field$)`

[bytes2mbytes(2)]
args = inField,outField
definition = eval "$outField$"='$inField$'/1048576

[bytes2gbytes(1)]
args = field
definition = `bytes2gbytes($field$,$field$)`

[bytes2gbytes(2)]
args = inField,outField
definition = eval "$outField$"='$inField$'/1073741824

## Globe distance
[globedistance(5)]
args = lat1,long1,lat2,long2,units
definition = `globedistance("distance",$lat1$,$long1$,$lat2$,$long2$,$units$,2)`

[globedistance(7)]
# The "precision" argument is numeric therefore unquoted.
args = outfield,lat1,long1,lat2,long2,units,precision
definition = eval lat1_r='$lat1$'*pi()/180 | eval lat2_r='$lat2$'*pi()/180 | eval delta=('$long2$'-'$long1$')*pi()/180 | eval R=if('$units$'="m",3959, 6372.8) | eval "$outfield$"=R*acos(sin(lat1_r)*sin(lat2_r) + cos(lat1_r) * cos(lat2_r) * cos(delta)) | eval "$outfield$"=round('$outfield$', $precision$) | fields - lat1_r,lat2_r,long1_r,long2_r,R,delta

## Standard deviation
[standard_deviations]
definition = inputlookup append=T standard_deviations

[stdev(2)]
args = intField,countField
definition = eventstats min($intField$) as min_$intField$,max($intField$) as max_$intField$,sum($countField$) as total | eventstats sum(eval($intField$*$countField$/total)) as mean_$intField$ | eventstats sum(eval(pow($intField$-mean_$intField$,2)*$countField$)) as sumsq | eval stdev=sqrt(sumsq/(total-1)) | `get_stdev_index($intField$)` | eval stdev=if(isnull(stdev),0,stdev)

## We can't single quote $Z$ at this time because of how it is invoked
## Currently we are invoking this with a negation operator
## | `stdev_desired_result(standard_deviation,mean_bytes,"gt_bytes")` | `stdev_desired_result(-standard_deviation,mean_bytes,"lt_bytes")`
[stdev_desired_result(3)]
args = Z,mean,outField
definition = eval "$outField$"=($Z$*stdev)+'$mean$'

[get_stdev_index(1)]
args = intField
definition = eval Z=(('$intField$'-'mean_$intField$')/stdev)

[get_delta]
args = 
definition = `get_delta(current_count,historical_count)`

[get_delta(2)]
args = field1,field2
definition = eval "$field1$"=if(isnum('$field1$'),'$field1$',0) | eval "$field2$"=if(isnum('$field2$'),'$field2$',0) | eval delta='$field1$'-'$field2$'


#############################
## Multivalued field handling
#############################

## Filters a value from a multi-valued field UNLESS it is the only value. 
[mvfilter_value(2)]
args = field, value
definition = eval "$field$"=if(mvcount('$field$')>1 AND '$field$'="$value$", mvfilter('$field$'!="$value$"), '$field$')

## Filters a field-value from a multi-valued field UNLESS it is the only value.
[mvfilter_field(2)]
args = field, filter_field
definition = eval `mvfilter_field_meval($field$,$filter_field$)`

[mvfilter_field_meval(2)]
args = field, filter_field
definition = "$field$"=if(mvcount('$filter_field$')=1 AND mvcount('$field$')>1 AND '$field$'='$filter_field$',split(ltrim(replace("|".mvjoin('$field$',"|"),"\|".'$filter_field$',""),"|"), "|"),'$field$')

## create a mv field from a sv field w/ default separator
[makemv(1)]
args = field
definition = `makemv($field$,"|")`

[makemv_meval(1)]
args = field
definition = `makemv_meval($field$,"|")`

## create a mv field from a sv field w/ user defined separator
[makemv(2)]
args = field, sep
definition = eval "$field$"=split('$field$',"$sep$")

[makemv_meval(2)]
args = field, sep
definition = "$field$"=split('$field$',"$sep$")

## create a sv field from a mv field w/ default separator
[makesv(1)]
args = field
definition = `makesv($field$,"|")`

## create a sv field from a mv field w/ user defined separator
[makesv(2)]
args = field, sep
definition = eval "$field$"=mvjoin('$field$',"$sep$")

## appends the values of field2 to field1
[mvappend_field(2)]
args = field1, field2
definition = eval "$field1$"=mvdedup(mvappend('$field1$',NULL,'$field2$'))

[mvappend_field_meval(2)]
args = field1, field2
definition = "$field1$"=mvdedup(mvappend('$field1$',NULL,'$field2$'))

## appends value to field
[mvappend_value(2)]
args = field, value
definition = eval "$field$"=mvdedup(mvappend('$field$',"$value$",NULL))

## appends value to field if bool==true
[mvappend_bool(3)]
args = field, value, bool
definition = eval "$field$"=if(match('$bool$', "1|[Tt]|[Tt][Rr][Uu][Ee]"),mvdedup(mvappend('$field$',"$value$",NULL)),'$field$')

[mvappend_bool_meval(3)]
args = field, value, bool
definition = "$field$"=if('$bool$'=="true",mvdedup(mvappend('$field$',"$value$",NULL)),'$field$')

## appends value to field if is_value==true
## i.e. appends "foo" to "bar" if "is_foo==true"
[mvappend_is(2)]
args = field, value
definition = `mvappend_bool($field$,$value$,"is_$value$")`

[mvappend_is_meval(2)]
args = field, value
definition = `mvappend_bool_meval($field$,$value$,"is_$value$")`

## appends should_value to field if should_value==true
## i.e. appends "should_foo" to "bar" if "should_foo==true"
[mvappend_should(2)]
args = field, value
definition = `mvappend_bool($field$,should_$value$,"should_$value$")`

[mvappend_should_meval(2)]
args = field, value
definition = `mvappend_bool_meval($field$,should_$value$,"should_$value$")`

## appends requires_value to field if requires_value==true
## i.e. appends "requires_foo" to "bar" if "requires_foo==true"
[mvappend_requires(2)]
args = field, value
definition = `mvappend_bool($field$,requires_$value$,"requires_$value$")`

[mvappend_requires_meval(2)]
args = field, value
definition = `mvappend_bool_meval($field$,requires_$value$,"requires_$value$")`

## mvdedup
## takes a multivalued field as input and creates a multivalued field containing only unique input values as output
[mvdedup(1)]
args = input
definition = `mvdedup($input$,$input$)`

[mvdedup(2)]
args = input, output
definition = eval "$output$"=mvdedup('$input$')

## mvtruncate
[mvtruncate(1)]
args = input
definition = `mvtruncate($input$,$input$,10)`

[mvtruncate(3)]
args = input, output, count
definition = eval "$output$"=if(mvcount('$input$')>$count$,mvappend(mvindex('$input$',0,$count$-1),NULL,"...truncated..."),'$input$')
errormsg = count (arg3) must be a number
validation = isnum(count)


#####################
## Integers
#####################

## 1.  Trim a number x (where x==11) of leading characters from _raw
## 1a. This is what the offset param for luhn_lookup.py does
## 2.  Pull out integer sequences based on regular expression
## 2a. Using \s and - as default separators
## 2b. For additional separators add additional "(?:\d+[<sep>]*){14,})" to the list
## 2c. {14,} defines minStrength y (where y==14)
[get_integer_seq]
definition = eval sub_raw=substr(_raw,11) | rex field=sub_raw max_match=10 "(?<integer_seq>(?:\d+[\s]*){14,}|(?:\d+[-]*){14,})"


#####################
## IP Address Utility
#####################

[ipv4_cidr_regex]
definition = "^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/(\d|[12]\d|3[012])$"


#####################
## SHC
#####################
[host_equal_local]
definition = rest splunk_server=local count=0 /services/server/info | table serverName | rename serverName as host

## 1.  Search
## 1a. Local server events only
## 1b. Internal Index
## 1c. All conf.log events
## 1d. Configuration push/pull events
## 1e. For specified configuration
## 1f. Status Applied
[shc_replication_change(1)]
args = config
definition = [| `host_equal_local`] index=_internal source=*conf.log (data.process="pullFrom" OR data.process="acceptPush") data.asset_uri{}="$config$" data.status="applied"


#####################
## Sorting
#####################
[sort_chart]
definition = `sort_chart(10)`

[sort_chart(1)]
args = head
definition = addtotals fieldname=Total | eval Total=if(isnotnull(src_port),Total-src_port,Total) | eval Total=if(isnotnull(dest_port),Total-dest_port,Total) | sort $head$ - Total | fields - Total
errormsg = head (arg1) must be an integer greater than zero
iseval = 0
validation = isint(head) AND head>0

[sort_chart(2)]
args = head, fields
definition = addtotals fieldname=Total $fields$ | sort $head$ - Total | fields - Total
errormsg = head (arg1) must be an integer greater than zero
iseval = 0
validation = isint(head) AND head>0


#####################
## Transformations
#####################

## lower
[lower(1)]
args = field1
definition = eval "$field1$"=lower('$field1$')

## namespace
[get_namespace]
definition = lookup local=true sourcetype2namespace sourcetype OUTPUT namespace

## transport_dest_port
[get_transport_dest_port]
args = 
definition = fillnull value=unknown transport | fillnull value=0 dest_port | eval transport_dest_port=transport."/".dest_port

[split_transport_dest_port(1)]
args = field
definition = rex field="$field$" "(?<transport>[^/]+)/(?<port>\d+)" | fillnull value=unknown transport | fillnull value=0 dest_port

## trim
[trim(1)]
args = field
definition = eval "$field$"=trim('$field$'," ")

## truncate
[truncate(2)]
args = field,length
definition = eval "$field$"=if(length('$field$')>$length$, substr('$field$', 0, $length$) + "...", '$field$')
errormsg = length (arg2) must be an integer greater than or equal to zero
iseval = 0
validation = isint(length) AND length>=0


#####################
## TSIDX
#####################
[tscollect(1)]
args = namespace
definition = `tscollect("$namespace$","true","false")`

[tscollect(2)]
args = namespace,squashcase
definition = `tscollect($namespace$,$squashcase$,"false")`

[tscollect(3)]
args = namespace,squashcase,keepresults
definition = tscollect namespace=$namespace$ squashcase=$squashcase$ keepresults=$keepresults$
errormsg = squashcase/keepresults (arg2/arg3) must be one of: true or false
iseval = 0
validation = (squashcase="true" OR squashcase="false") AND (keepresults="true" OR keepresults="false")

[tstats]
definition = tstats prestats=true local=`tstats_local` `summariesonly`

[tstats_local]
definition = false

## This macro has been deprecated
[allow_old_summaries_bool]
definition = true


#####################
## Users
#####################

## get_realname breakdown
## 1 - Lookup the users realname in user_realnames collection
## 2 - If the realname could not be found, use the username
[get_realname(1)]
args = user
definition = lookup update=true user_realnames_lookup user as "$user$" OUTPUTNEW realname as "$user$_realname" | eval "$user$_realname"=if(isnull('$user$_realname'),'$user$','$user$_realname')


#####################
## SA-Utils internal
#####################
[script_error_msg_ignore]
definition = (match(script, "(streamfwd|splunk-(wmi\.path|MonitorNoHandle\.exe|winevtlog\.exe|netmon\.exe|perfmon\.exe|regmon\.exe|winprintmon\.exe|admon\.exe|powershell\.exe))") AND exit_status=1) OR (script LIKE "%instrumentation.py" AND exit_status=114)

[get_dashboards_usage(3)]
args = Splunk_Role,app,Dashboard_Name
definition = lookup splunk_web_access_kv_store_lookup Splunk_Role AS $Splunk_Role$ App AS $app$ Dashboard_Name AS $Dashboard_Name$ OUTPUTNEW Earliest_Access_Updated AS Dash_Earliest_Access_Updated Latest_Access_Updated AS Dash_Latest_Access_Updated min_spent AS Dash_min_spent max_spent AS Dash_max_spent avg_spent AS Dash_avg_spent\
\
| eval Dash_Earliest_Access_Updated = strftime(Dash_Earliest_Access_Updated,"%m/%d/%Y %H:%M:%S") , Dash_Latest_Access_Updated = strftime(Dash_Latest_Access_Updated,"%m/%d/%Y %H:%M:%S")\
\
| fillnull value="Undefined" Dash_Earliest_Access_Updated Dash_Latest_Access_Updated Dash_min_spent Dash_max_spent Dash_avg_spent
iseval = 0

[get_saved_searches_usage(3)]
args = Splunk_Role,app,Savedsearch_Name
definition = lookup splunk_sh_index_internal_scheduler_jobs_kv_store_lookup Splunk_Role AS $Splunk_Role$ App AS $app$ Savedsearch_Name AS $Savedsearch_Name$ OUTPUTNEW Splunk_Instance AS Rep_Splunk_Instance User AS Rep_User Scheduled_Time AS Rep_Scheduled_Time Priority AS Rep_Priority Dispatch_Time AS Rep_Dispatch_Time Window_Time AS Rep_Window_Time Latest_Run_Time AS Rep_Latest_Run_Time Run_Time AS Rep_Run_Time Result_Count AS Rep_Result_Count\
| eval Rep_Scheduled_Time = strftime(Rep_Scheduled_Time,"%m/%d/%Y %H:%M:%S") , Rep_Dispatch_Time = strftime(Rep_Dispatch_Time,"%m/%d/%Y %H:%M:%S") , Rep_Latest_Run_Time = strftime(Rep_Latest_Run_Time,"%m/%d/%Y %H:%M:%S")\
| fillnull value="Undefined" Rep_Splunk_Instance Rep_User Rep_Scheduled_Time Rep_Priority Rep_Dispatch_Time Rep_Window_Time Rep_Latest_Run_Time Rep_Run_Time Rep_Result_Count
iseval = 0

[get_identity_info(1)]
args = username
definition = lookup update=true identity_lookup Identity as $username$ OUTPUTNEW Name,Title,Phone,Email,Emp_Type,Emp_Status,City,State,Country,Region,Location_Code,Floor_Number,startDate,endDate,Department,LOB,Cost_Center,Manager,Contractor_Expiration\
\
| fillnull value="Undefined" Name,Title,Phone,Email,Emp_Type,Emp_Status,City,State,Country,Region,Location_Code,Floor_Number,startDate,endDate,Department,LOB,Cost_Center,Manager,Contractor_Expiration
iseval = 0

[get_identity_usage(1)]
args = username
definition = lookup splunk_sh_index_audit_user_login_kv_store_lookup User AS $username$ OUTPUTNEW Earliest_Login_Updated AS User_Earliest_Login_Updated Latest_Login_Updated AS User_Latest_Login_Updated Splunk_Role AS User_Splunk_Role Login_Source AS User_Login_Source\
\
| eval User_Earliest_Login_Updated = strftime(User_Earliest_Login_Updated,"%m/%d/%Y %H:%M:%S") , User_Latest_Login_Updated = strftime(User_Latest_Login_Updated,"%m/%d/%Y %H:%M:%S")\
\
| fillnull value="Undefined" User_Earliest_Login_Updated User_Latest_Login_Updated User_Splunk_Role User_Login_Source
iseval = 0

[get_field_desc(1)]
args = Field_Name
definition = lookup splunk_fields_lookup Field_Name AS $Field_Name$ OUTPUTNEW Field_Description
iseval = 0

[get_lookup_reference(1)]
args = field
definition = rex field=$field$ max_match=0 "\|\s*lookup\s*(?<Lookup_Reference1>\w+)" \
| rex field=$field$ max_match=0 "\|\s*(input|output)lookup\s*(append=\w+\s+)?(?<Lookup_Reference2>\w+)" \
| rex field=$field$ max_match=0 "from\s+lookup:(?<Lookup_Reference3>\w+)" \
| eval Lookup_Reference=mvsort(mvdedup(mvappend(Lookup_Reference1, Lookup_Reference2, Lookup_Reference3)))\
\
| fillnull value="Undefined" Lookup_Reference
iseval = 0

[get_saved_searches_info(1)]
args = Savedsearch_Name
definition = lookup shc_saved_searches_rest_kv_store_lookup savedsearch_name AS $Savedsearch_Name$ OUTPUTNEW description savedsearch_type cron_schedule\
| fillnull value="Undefined" description savedsearch_type cron_schedule
iseval = 0

[get_splunk_env(1)]
args = host
definition = eval $host$=upper($host$) \
| lookup splunk_assets_lookup host AS $host$ OUTPUT Splunk_Role AS Splunk_Role\
| fillnull value="Unknown" Splunk_Role
iseval = 0
